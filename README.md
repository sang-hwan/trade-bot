**코드 작성 시 주의점**
> Python 버전: 3.11 이상 (python --version으로 확인)
1. 표준 라이브러리 **우선 사용**.
2. **코드 청소**: 동작·출력·공개 API는 유지한 채 미사용 import/변수/함수, 주석 처리된 코드, 임시 디버그 출력, 죽은/불필요 분기, 광범위 예외(pass) 제거.
3. **주석 가이드**: 공개 API 계약, 수식/타이밍 규약, 예외 처리 근거에 한해 **간결하게** 사용(중복·잡설 금지).

# 안내문

## 목적
- 같은 방법으로 실행하면 항상 같은 결과가 나오게 함
- 전략은 규칙을 정의하고 시뮬레이션은 그 규칙을 그대로 집행함

## 규칙

### 시간·우선순위
- 신호 판정: D-1 종가(UTC)
- 주문 집행: D일 시가(UTC)
- 겹칠 경우 스탑이 신호보다 우선
- 미래 값은 사용하지 않음

### 반올림·통화
- 수량은 수량 단위 `lot_step`, 가격은 가격 단위 `price_step`에 맞춰 주문
- 모든 금액은 하나의 기준 통화로 계산
- 다른 통화 금액은 해당 일자의 환율로 환산 후 계산

### 표기
- 개념은 한국어, 변수·파일·필드는 `code` 표기 사용
- 조정된 가격(Adjusted price)은 가능하면 조정된 값을 우선 사용
- 거래 사유 라벨은 `signal` `stop` `rebalance` 중 하나만 사용
- 최대낙폭(MDD)은 첫 등장에만 약어 병기

### 산출물·메타 라벨
- 거래 기록 `trades`, 자본 곡선 `equity_curve`, 요약 지표 `metrics`
- 스냅샷 메타 `snapshot_meta`, 실행 메타 `run_meta`

---

## 데이터

### `data/collect.py` 수집
- 하는 일: 시장 가격 표를 모아 컬럼 이름과 시간 기준(UTC)을 표준화
- 왜 필요한가: 이후 단계가 항상 같은 형태의 입력을 받아 오류를 줄이기 위함
- 언제 쓰나요: 작업 시작 시 원천 데이터를 표준 형태로 정리할 때

### `data/quality_gate.py` 검사
- 하는 일: 빈 값, 이상치, 시간 순서, 중복 시간을 검증
- 왜 필요한가: 잘못된 표를 초기에 차단해 뒤 단계 오류를 예방
- 언제 쓰나요: 수집 직후 본격 처리 전에

### `data/adjust.py` 조정
- 하는 일: 조정된 시가·고가·저가·종가 컬럼 생성
- 왜 필요한가: 분할·배당 등 이벤트가 있어도 공정 비교를 가능하게 함
- 언제 쓰나요: 검사를 통과한 뒤 조정된 가격이 필요한 경우

### `data/snapshot.py` 저장
- 하는 일: 표를 Parquet로 저장하고 SHA-256 해시와 `snapshot_meta`를 함께 기록
- 왜 필요한가: 같은 입력이면 같은 결과임을 검증 가능하게 함
- 언제 쓰나요: 데이터 준비 완료 후 고정본을 남길 때

---

## 전략

### `strategy/features.py` 특징
- 하는 일: 단순이동평균(SMA), 일정 기간 최저값 등 핵심 특징 생성
- 왜 필요한가: 하위 단계가 이 값을 기준으로 신호와 스탑을 판단
- 언제 쓰나요: 매일 종가 확정 이후

### `strategy/signals.py` 신호
- 하는 일: 내일 매수 여부를 1/0으로 표시
- 왜 필요한가: 매수 결정을 단일 숫자로 표현해 집행과 검증을 단순화
- 언제 쓰나요: D-1 종가(UTC)로 판정하고 D일 시가(UTC)에 집행

### `strategy/stops.py` 스탑
- 하는 일: 오늘 종가가 일정 기간 최저값 이하이면 D일 시가(UTC) 매도를 표기하고 `stop_level` 기록
- 왜 필요한가: 손실 제한을 위해 사전 청산 기준을 명시
- 언제 쓰나요: D-1 종가(UTC)로 판단하고 D일 시가(UTC)에 집행

### `strategy/sizing_spec.py` 사이징 스펙
- 하는 일: 위험 사용 비율 `f`, `stop_level`, `lot_step` 등 집행에 필요한 입력 표 생성
- 왜 필요한가: 시뮬레이션이 현재 시점 정보만으로 안전한 수량을 계산하도록 보장
- 언제 쓰나요: 아침 집행 직전 수량 산정 시 읽어 사용

### `strategy/rebalancing_spec.py` 리밸런싱 스펙
- 하는 일: 목표 비중과 현금 흐름을 바탕으로 부족 자산 매수량과 과체중 자산 매도량을 산출
- 왜 필요한가: 불필요한 매매를 줄이고 현금만으로 목표 비중에 가깝게 맞춤
- 언제 쓰나요: 스탑·신호 처리 후 아침 집행 시 비중 조정 단계

---

## 시뮬레이션

### `simulation/engine.py` 엔진
- 하는 일: 아침에 스탑 → 신호 순서로 집행하고 조정된 가격이 있으면 우선 사용하며 결과를 기록
- 왜 필요한가: 전략을 정해 둔 순서와 규칙대로 일관 집행
- 언제 쓰나요: 매일 아침 주문 생성 시

### `simulation/execution.py` 체결
- 하는 일: 집행 가격 생성, 슬리피지 반영, 가격 단위 반올림/내림, 수수료 반영, 현금 잔액 갱신
- 왜 필요한가: 모든 주문을 동일 규칙으로 계산해 공정성을 확보
- 언제 쓰나요: 주문 생성 및 자금 업데이트 시

### `simulation/sizing_on_open.py` 수량 계산(아침)
- 하는 일: D일 시가(UTC)에 사용할 주문 수량을 계산
- 왜 필요한가: 현재 시점 정보만으로 안전한 수량을 결정
- 언제 쓰나요: 집행 직전 수량 확정 시

### `simulation/outputs.py` 산출물
- 하는 일: `trades` `equity_curve` `metrics` `run_meta` 생성
- 왜 필요한가: 결과 비교와 재현 실행을 표준 형식으로 지원
- 언제 쓰나요: 집행 종료 후 정리 및 저장 시

---

## 검증

### `validation/data_gate.py` 데이터 확인
- 하는 일: 표와 `snapshot_meta`의 정합성 검사(시간 순서, 중복, 행·열 수, SHA-256 일치)
- 왜 필요한가: 초기 입력 오류를 제거해 이후 단계의 안전성을 확보
- 언제 쓰나요: 스냅샷 저장 직후

### `validation/strategy_gate.py` 전략 확인
- 하는 일: 시간 규칙과 우선순위 준수 여부 확인(신호 D-1→D, 스탑 D-1→D, 스탑 우선) 및 조정된 가격 사용 점검
- 왜 필요한가: 시간 규칙 위반은 결과를 왜곡하므로 사전 차단 필요
- 언제 쓰나요: 집행 전에 규칙 위반 여부 점검

### `validation/simulation_gate.py` 시뮬레이션 확인
- 하는 일: 집행 가격, 반올림/내림, 수수료, 금액 계산 검증과 수량의 `lot_step` 배수 여부 확인
- 왜 필요한가: 주문 계산의 일관성과 정확성 보장
- 언제 쓰나요: 집행 후 계산 검증 시

### `validation/analysis_viz.py` 분석·그림
- 하는 일: 자본 곡선, 최대낙폭, 거래별 손익 등 결과를 그림과 숫자로 저장
- 왜 필요한가: 성과를 한눈에 파악하고 간단한 지표로 비교 가능하게 함
- 언제 쓰나요: 검증 완료 후 보고 자료 생성 시

---

## 실매매

### `live/plan_auto.py` 계획 수립
-   하는 일: **(1단계: 일일 계획 수립)** D-1 종가까지의 데이터를 바탕으로 `strategy` 모듈의 로직(신호, 스탑, 사이징)을 사용하여 D일 시가에 실행할 **매매 계획 초안**(`stops_list`, `signals_map`)을 자동으로 생성합니다.
-   왜 필요한가: 실매매의 **'두뇌'** 역할을 수행하며, 백테스트와 동일한 전략적 판단을 라이브 환경에서 재현하기 위함입니다.
-   언제 쓰나요: `run_live.py` 실행 시 가장 먼저 호출되어, 당일 매매의 전체적인 방향과 대상을 결정합니다.

### `live/order_router.py` 주문 라우터
-   하는 일: **(2단계: 주문 목록 생성)** `plan_auto.py`가 생성한 계획과 현재 계좌 상태(보유 포지션)를 입력받아, **스탑 → 신호 → 리밸런싱** 우선순위에 따라 실제 증권사에 보낼 주문 목록을 생성하고 최적화(상쇄, 병합)합니다.
-   왜 필요한가: 시간·우선순위 규칙과 `lot_step` 같은 제약조건을 실제 주문에 강제하고, 불필요한 거래를 줄이기 위함입니다.
-   언제 쓰나요: 계획 수립 직후, 실제 주문을 증권사에 보내기 전 최종 주문 리스트를 확정할 때 사용합니다.

### `live/broker_adapter.py` 브로커 어댑터
-   하는 일: **(3단계: API 통신)** 프로젝트의 표준 주문 요청을 실제 증권사(한국투자증권) API가 이해할 수 있는 형식으로 변환하고 통신을 수행합니다. `place_order`, `fetch_cash` 등 표준 인터페이스를 제공합니다.
-   왜 필요한가: 브로커별 API 차이를 숨기고, 엔진이 생성한 주문을 일관된 방식으로 집행하기 위함입니다.
-   언제 쓰나요: `run_live.py`가 **'2단계 집행'**을 수행할 때(매도 주문 선집행 → 현금 재조회 → 매수 주문 집행) 및 계좌 상태를 조회할 때 사용됩니다.

### `live/fills.py` 체결 수집
-   하는 일: **(4단계: 체결 내역 수집)** 증권사 API를 주기적으로 폴링하여 실제 체결된 내역(`fill`)을 수집하고, 프로젝트 표준 형식으로 변환합니다.
-   왜 필요한가: 주문이 실제로 얼마나, 어떤 가격에 체결되었는지 확인하여 정확한 회계 처리의 기반을 마련하기 위함입니다.
-   언제 쓰나요: `run_live.py`의 `--loop` 모드에서 주기적으로 호출되어 실시간 체결 상황을 반영합니다.

### `live/reconcile.py` 체결 대사
-   하는 일: **(5단계: 회계 처리)** 의도했던 주문과 수집된 실제 체결 내역을 비교·매칭하고, 수수료 등을 반영하여 최종 포지션과 현금 잔고를 정확하게 갱신합니다.
-   왜 필요한가: 시뮬레이션과 동일한 회계 규칙으로 실적을 기록하여 성과 비교의 신뢰도를 확보하기 위함입니다.
-   언제 쓰나요: `run_live.py`의 `--loop` 모드에서 주기적으로 호출되어 누적된 체결 내역을 바탕으로 자산 상태를 최신화합니다.

### `live/outputs.py` 산출물
-   하는 일: **(6단계: 결과 기록)** 회계 처리가 완료된 실매매 결과를 시뮬레이션과 **100% 동일한 스키마**(`trades`, `equity_curve` 등)로 파일에 기록하고, 원본 주문·체결 로그도 보관합니다.
-   왜 필요한가: 백테스트와 실거래 결과를 1:1로 비교하고 검증할 수 있도록 표준화된 결과물을 남기기 위함입니다.
-   언제 쓰나요: 체결 대사 완료 후, `run_live.py`가 일일 결과물을 파일로 저장할 때 사용됩니다.

---

## 모니터링

### `monitoring/health_checks.py` 시스템 헬스 체크
- 하는 일: 브로커 API 연결, 레이트 리밋, 인증, 시계 동기화, 거래 캘린더·시가 도달 여부를 점검
- 왜 필요한가: 집행 실패나 지연을 사전에 탐지해 리스크를 줄이기 위함
- 언제 쓰나요: 장 전 주기적(예: 1분 간격) 및 집행 직전·직후

### `monitoring/rule_watchers.py` 규칙 감시
- 하는 일: 스탑 > 신호 우선, D-1→D 시간 규칙, `price_step` `lot_step` 준수, 예상 대비 슬리피지·수수료 드리프트를 감시
- 왜 필요한가: 규칙 위반과 비용 이상 징후를 조기에 발견하기 위함
- 언제 쓰나요: 주문 생성 시, 체결 수신 시, 일일 마감 시

### `monitoring/alerts.py` 알림
- 하는 일: 임계값 초과(MDD, 슬리피지, 체결 지연, 포지션 불일치 등) 시 알림 채널로 통지하고 근거 데이터를 첨부
- 왜 필요한가: 운영자가 즉시 대응할 수 있도록 신호를 제공하기 위함
- 언제 쓰나요: 감시 항목 발생 즉시

### `monitoring/daily_report.py` 일일 리포트
- 하는 일: 일일 `trades` `equity_curve` `metrics` 요약, 규칙 위반·장애 로그, 다음 영업일 TODO를 정리해 저장
- 왜 필요한가: 실행·검증·운영 히스토리를 일관된 포맷으로 축적하기 위함
- 언제 쓰나요: 장 마감 이후 배치 시간대

---

## 전체 흐름

이 프로젝트는 크게 **백테스트**, **검증**, **실매매**의 세 가지 독립적인 파이프라인으로 구성됩니다.

### 1. 백테스트 흐름
과거 데이터로 전략의 성과를 시뮬레이션하고 기본 결과물을 생성합니다.

* **데이터 수집** → **품질 검사** → **가격 조정** → **데이터 스냅샷 저장** (선택 사항) → **시뮬레이션 엔진 실행** → **산출물 저장**
    * *주의: 백테스트의 시뮬레이션 엔진은 내부에 구현된 자체 로직을 통해 특징 계산, 신호 및 스탑 판정, 수량 계산, 가상 체결을 모두 처리합니다*.

### 2. 검증 흐름
백테스트 결과물이 모든 규칙을 준수했는지 독립적으로 감사하고 상세 리포트를 생성합니다.

* **입력 데이터의 무결성 확인** → **전략 규칙 준수 여부 확인** → **시뮬레이션 회계 계산 확인** → **분석 및 시각화 리포트 생성**

### 3. 실매매 흐름
검증된 전략을 실제 증권사 계좌에서 실행합니다.

* **일일 매매 계획 수립**
    * **기술적 특징 계산** → **진입 신호 생성** → **손절 규칙 생성** → **주문 수량 계획** → **포트폴리오 비중 조절 계획**
* **실시간 매매 실행**
    * **최종 주문 목록 생성** → **증권사 API 통신** → **실제 체결 내역 수집** → **계좌 회계 처리** → **결과 기록**
* **시스템 모니터링**
