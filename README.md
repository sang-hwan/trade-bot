**코드 작성 시 주의점**
> Python 버전: 3.11 이상 (python --version으로 확인)
1. 표준 라이브러리 **우선 사용**.
2. **코드 청소**: 동작·출력·공개 API는 유지한 채 미사용 import/변수/함수, 주석 처리된 코드, 임시 디버그 출력, 죽은/불필요 분기, 광범위 예외(pass) 제거.
3. **주석 가이드**: 공개 API 계약, 수식/타이밍 규약, 예외 처리 근거에 한해 **간결하게** 사용(중복·잡설 금지).

# 안내문

## 목적
- 같은 방법으로 실행하면 항상 같은 결과가 나오게 함
- 전략은 규칙을 정의하고 시뮬레이션은 그 규칙을 그대로 집행함

## 규칙

### 시간·우선순위
- 신호 판정: D-1 종가(UTC)
- 주문 집행: D일 시가(UTC)
- 겹칠 경우 스탑이 신호보다 우선
- 미래 값은 사용하지 않음

### 반올림·통화
- 수량은 수량 단위 `lot_step`, 가격은 가격 단위 `price_step`에 맞춰 주문
- 모든 금액은 하나의 기준 통화로 계산
- 다른 통화 금액은 해당 일자의 환율로 환산 후 계산

### 표기
- 개념은 한국어, 변수·파일·필드는 `code` 표기 사용
- 조정된 가격(Adjusted price)은 가능하면 조정된 값을 우선 사용
- 거래 사유 라벨은 `signal` `stop` `rebalance` 중 하나만 사용
- 최대낙폭(MDD)은 첫 등장에만 약어 병기

### 산출물·메타 라벨
- 거래 기록 `trades`, 자본 곡선 `equity_curve`, 요약 지표 `metrics`
- 스냅샷 메타 `snapshot_meta`, 실행 메타 `run_meta`

---

## 데이터

### `data/collect.py` 수집
- 하는 일: 시장 가격 표를 모아 컬럼 이름과 시간 기준(UTC)을 표준화
- 왜 필요한가: 이후 단계가 항상 같은 형태의 입력을 받아 오류를 줄이기 위함
- 언제 쓰나요: 작업 시작 시 원천 데이터를 표준 형태로 정리할 때

### `data/quality_gate.py` 검사
- 하는 일: 빈 값, 이상치, 시간 순서, 중복 시간을 검증
- 왜 필요한가: 잘못된 표를 초기에 차단해 뒤 단계 오류를 예방
- 언제 쓰나요: 수집 직후 본격 처리 전에

### `data/adjust.py` 조정
- 하는 일: 조정된 시가·고가·저가·종가 컬럼 생성
- 왜 필요한가: 분할·배당 등 이벤트가 있어도 공정 비교를 가능하게 함
- 언제 쓰나요: 검사를 통과한 뒤 조정된 가격이 필요한 경우

### `data/snapshot.py` 저장
- 하는 일: 표를 Parquet로 저장하고 SHA-256 해시와 `snapshot_meta`를 함께 기록
- 왜 필요한가: 같은 입력이면 같은 결과임을 검증 가능하게 함
- 언제 쓰나요: 데이터 준비 완료 후 고정본을 남길 때

---

## 전략

### `strategy/features.py` 특징
- 하는 일: 단순이동평균(SMA), 일정 기간 최저값 등 핵심 특징 생성
- 왜 필요한가: 하위 단계가 이 값을 기준으로 신호와 스탑을 판단
- 언제 쓰나요: 매일 종가 확정 이후

### `strategy/signals.py` 신호
- 하는 일: 내일 매수 여부를 1/0으로 표시
- 왜 필요한가: 매수 결정을 단일 숫자로 표현해 집행과 검증을 단순화
- 언제 쓰나요: D-1 종가(UTC)로 판정하고 D일 시가(UTC)에 집행

### `strategy/stops.py` 스탑
- 하는 일: 오늘 종가가 일정 기간 최저값 이하이면 D일 시가(UTC) 매도를 표기하고 `stop_level` 기록
- 왜 필요한가: 손실 제한을 위해 사전 청산 기준을 명시
- 언제 쓰나요: D-1 종가(UTC)로 판단하고 D일 시가(UTC)에 집행

### `strategy/sizing_spec.py` 사이징 스펙
- 하는 일: 위험 사용 비율 `f`, `stop_level`, `lot_step` 등 집행에 필요한 입력 표 생성
- 왜 필요한가: 시뮬레이션이 현재 시점 정보만으로 안전한 수량을 계산하도록 보장
- 언제 쓰나요: 아침 집행 직전 수량 산정 시 읽어 사용

### `strategy/rebalancing_spec.py` 리밸런싱 스펙
- 하는 일: 목표 비중과 현금 흐름을 바탕으로 부족 자산 매수량과 과체중 자산 매도량을 산출
- 왜 필요한가: 불필요한 매매를 줄이고 현금만으로 목표 비중에 가깝게 맞춤
- 언제 쓰나요: 스탑·신호 처리 후 아침 집행 시 비중 조정 단계

---

## 시뮬레이션

### `simulation/engine.py` 엔진
- 하는 일: 아침에 스탑 → 신호 순서로 집행하고 조정된 가격이 있으면 우선 사용하며 결과를 기록
- 왜 필요한가: 전략을 정해 둔 순서와 규칙대로 일관 집행
- 언제 쓰나요: 매일 아침 주문 생성 시

### `simulation/execution.py` 체결
- 하는 일: 집행 가격 생성, 슬리피지 반영, 가격 단위 반올림/내림, 수수료 반영, 현금 잔액 갱신
- 왜 필요한가: 모든 주문을 동일 규칙으로 계산해 공정성을 확보
- 언제 쓰나요: 주문 생성 및 자금 업데이트 시

### `simulation/sizing_on_open.py` 수량 계산(아침)
- 하는 일: D일 시가(UTC)에 사용할 주문 수량을 계산
- 왜 필요한가: 현재 시점 정보만으로 안전한 수량을 결정
- 언제 쓰나요: 집행 직전 수량 확정 시

### `simulation/outputs.py` 산출물
- 하는 일: `trades` `equity_curve` `metrics` `run_meta` 생성
- 왜 필요한가: 결과 비교와 재현 실행을 표준 형식으로 지원
- 언제 쓰나요: 집행 종료 후 정리 및 저장 시

---

## 검증

### `validation/data_gate.py` 데이터 확인
- 하는 일: 표와 `snapshot_meta`의 정합성 검사(시간 순서, 중복, 행·열 수, SHA-256 일치)
- 왜 필요한가: 초기 입력 오류를 제거해 이후 단계의 안전성을 확보
- 언제 쓰나요: 스냅샷 저장 직후

### `validation/strategy_gate.py` 전략 확인
- 하는 일: 시간 규칙과 우선순위 준수 여부 확인(신호 D-1→D, 스탑 D-1→D, 스탑 우선) 및 조정된 가격 사용 점검
- 왜 필요한가: 시간 규칙 위반은 결과를 왜곡하므로 사전 차단 필요
- 언제 쓰나요: 집행 전에 규칙 위반 여부 점검

### `validation/simulation_gate.py` 시뮬레이션 확인
- 하는 일: 집행 가격, 반올림/내림, 수수료, 금액 계산 검증과 수량의 `lot_step` 배수 여부 확인
- 왜 필요한가: 주문 계산의 일관성과 정확성 보장
- 언제 쓰나요: 집행 후 계산 검증 시

### `validation/analysis_viz.py` 분석·그림
- 하는 일: 자본 곡선, 최대낙폭, 거래별 손익 등 결과를 그림과 숫자로 저장
- 왜 필요한가: 성과를 한눈에 파악하고 간단한 지표로 비교 가능하게 함
- 언제 쓰나요: 검증 완료 후 보고 자료 생성 시

---

## 실매매

### `live/broker_adapter.py` 브로커 어댑터
- 하는 일: 브로커 API를 표준 인터페이스로 추상화하고 `place_order` `cancel_order` `fetch_positions` `fetch_cash` `fetch_price`를 제공
- 왜 필요한가: 브로커별 차이를 숨기고 엔진 산출 주문을 동일한 방식으로 집행하기 위함
- 언제 쓰나요: D일 시가(UTC) 집행 직전·직후 및 포지션 동기화 시

### `live/order_router.py` 주문 라우터
- 하는 일: 스탑 → 신호 → 리밸런싱 순으로 주문을 생성·정렬하고 `price_step` `lot_step` 규칙을 적용해 중복·과도 주문을 제거
- 왜 필요한가: 시간·우선순위 규칙과 반올림 규칙을 실거래에 그대로 강제하기 위함
- 언제 쓰나요: 집행 직전 최종 주문 리스트를 확정할 때

### `live/reconcile.py` 체결 대사
- 하는 일: 브로커 체결 내역을 수신해 의도 주문과 매칭하고 수수료·세금 반영 후 포지션·현금 잔액을 갱신
- 왜 필요한가: 시뮬레이션 산출과 동일한 회계 규칙으로 실적을 기록하기 위함
- 언제 쓰나요: 집행 직후부터 장마감까지 체결 발생 시마다

### `live/outputs.py` 산출물
- 하는 일: `trades` `equity_curve` `metrics` `run_meta`를 시뮬레이션과 동일 스키마로 기록하고 주문·체결 로그를 보관
- 왜 필요한가: 백테스트와 실거래 결과를 1:1로 비교·검증 가능하게 하기 위함
- 언제 쓰나요: 체결 대사 완료 시점과 일일 마감 배치 시

---

## 모니터링

### `monitoring/health_checks.py` 시스템 헬스 체크
- 하는 일: 브로커 API 연결, 레이트 리밋, 인증, 시계 동기화, 거래 캘린더·시가 도달 여부를 점검
- 왜 필요한가: 집행 실패나 지연을 사전에 탐지해 리스크를 줄이기 위함
- 언제 쓰나요: 장 전 주기적(예: 1분 간격) 및 집행 직전·직후

### `monitoring/rule_watchers.py` 규칙 감시
- 하는 일: 스탑 > 신호 우선, D-1→D 시간 규칙, `price_step` `lot_step` 준수, 예상 대비 슬리피지·수수료 드리프트를 감시
- 왜 필요한가: 규칙 위반과 비용 이상 징후를 조기에 발견하기 위함
- 언제 쓰나요: 주문 생성 시, 체결 수신 시, 일일 마감 시

### `monitoring/alerts.py` 알림
- 하는 일: 임계값 초과(MDD, 슬리피지, 체결 지연, 포지션 불일치 등) 시 알림 채널로 통지하고 근거 데이터를 첨부
- 왜 필요한가: 운영자가 즉시 대응할 수 있도록 신호를 제공하기 위함
- 언제 쓰나요: 감시 항목 발생 즉시

### `monitoring/daily_report.py` 일일 리포트
- 하는 일: 일일 `trades` `equity_curve` `metrics` 요약, 규칙 위반·장애 로그, 다음 영업일 TODO를 정리해 저장
- 왜 필요한가: 실행·검증·운영 히스토리를 일관된 포맷으로 축적하기 위함
- 언제 쓰나요: 장 마감 이후 배치 시간대

---

## 전체 흐름
수집 → 검사 → 조정 → 저장 → 특징 → 신호 → 스탑 → 사이징 스펙 → 리밸런싱 스펙 → 엔진 → 체결 → 수량 계산 → 산출물 → 데이터 확인 → 전략 확인 → 시뮬레이션 확인 → 분석·그림 → 실매매 → 모니터링
