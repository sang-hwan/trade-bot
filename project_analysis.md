### 📜 백테스트 실행 흐름 (`backtest.py`)

`backtest.py`는 데이터 처리부터 시뮬레이션, 결과 저장까지의 전 과정을 지휘합니다. 특히 시뮬레이션 단계에서는 외부 `strategy` 모듈이 아닌, `simulation/engine.py` 내부에 구현된 자체 전략 로직을 사용합니다.

**`backtest.py` 실행**
> **1. `main()`**
> > **파일**: `backtest.py`
> > **역할**: 스크립트의 **최상위 진입점**입니다. 명령줄 인자를 파싱하고 결과물이 저장될 출력 디렉터리를 구성(`_compose_out_dir` 호출)한 뒤, 핵심 오케스트레이션 함수인 `run_once`를 실행합니다.
>
> **2. `run_once()`**
> > **파일**: `backtest.py`
> > **역할**: 백테스트의 전 과정을 지휘하는 **핵심 오케스트레이터**입니다. 데이터 처리부터 시뮬레이션, 결과 저장까지 모든 단계를 순서대로 호출하고 관리합니다.
> >
> > **2-1. `collect()`**
> > > **파일**: `data/collect.py`
> > > **역할**: **(수집)** 인자로 받은 `source`에 따라 `fetch_yahoo_ohlcv()` 또는 `fetch_upbit_ohlcv()`를 호출하여 원본 데이터를 수집하고, `_to_utc_index()`로 인덱스를 표준화한 후 `CollectResult` 클래스에 담아 반환합니다.
> >
> > **2-2. `validate()`**
> > > **파일**: `data/quality_gate.py`
> > > **역할**: **(데이터 검증)** `_assert_columns()`, `_assert_index_is_utc_dtindex()`, `_assert_monotonic_strict_and_no_duplicates()` 등 내부 검증 함수들을 호출하여 수집된 데이터의 무결성을 검사합니다.
> >
> > **2-3. `apply()`**
> > > **파일**: `data/adjust.py`
> > > **역할**: **(가격 조정)** `AdjClose`와 `close`의 비율을 이용해 조정 계수를 계산하고, 이를 모든 OHLC 가격에 적용하여 `*_adj` 컬럼을 생성합니다.
> >
> > **2-4. `validate_meta()`**
> > > **파일**: `data/quality_gate.py`
> > > **역할**: **(메타 검증)** `lot_step`, `price_step`, 기준 통화 등 시뮬레이션에 필요한 메타 정보가 유효한지(예: 양수인지) 검사합니다.
> >
> > **2-5. `write()` (조건부)**
> > > **파일**: `data/snapshot.py`
> > > **역할**: **(스냅샷)** `--snapshot` 옵션이 있을 때만 실행됩니다. `_to_parquet_with_fallback()`으로 데이터를 Parquet 파일로 저장하고, `_file_sha256()`으로 파일 해시를 계산한 뒤, 이 모든 정보를 `SnapshotMeta` 클래스에 담아 반환합니다.
> >
> > **2-6. `run()`**
> > > **파일**: `simulation/engine.py`
> > > **역할**: **(시뮬레이션)** 최종 데이터를 바탕으로 트레이딩 전략을 실행하고 모든 거래와 자산 변화를 기록합니다.
> > > * **`_build_features()`, `_build_decisions()`, `_build_stop_flags()` 호출 (내부 함수)**: **`engine.py` 파일 내에서** 이동평균, 진입 신호, 스탑 조건을 직접 계산합니다. 이는 외부 `strategy` 폴더의 파일을 사용하지 않는 **핵심적인 부분**입니다.
> > > * **`open_eff()` 호출 (from `simulation/execution.py`)**: 매일의 루프 안에서, 슬리피지와 가격 단위를 고려한 실제 체결 예상 가격을 계산합니다.
> > > * **Sizing Logic (내장)**: 현재 자산과 리스크(`f`), 진입가, 손절가를 이용해 적절한 주문 수량을 계산합니다. 이 로직은 `simulation/sizing_on_open.py`의 원리를 따릅니다.
> > > * **`Trade` (클래스)**: 발생한 모든 거래의 상세 내역을 `Trade` 객체에 기록합니다.
> > > * **`_metrics()` 호출**: 시뮬레이션 종료 후, `_mdd()` 함수를 이용해 최대 자본 하락률을 계산하는 등 최종 성과 지표를 산출합니다.
> >
> > **2-7. 산출물 저장**
> > > **파일**: `backtest.py` (내장 로직)
> > > **역할**: **(결과 저장)** 시뮬레이션 엔진이 반환한 모든 결과물(거래 내역, 자본 곡선, 지표, 실행 메타)을 표준 형식의 파일로 저장하며 파이프라인을 종료합니다.
> > > * `pandas.DataFrame.to_csv()`: `trades`와 `equity_curve` 데이터를 CSV 파일로 저장합니다.
> > > * `json.dumps()`: `metrics`와 `run_meta` 딕셔너리를 사람이 읽기 좋은 JSON 형식으로 저장합니다.

---

### ⚙️ 실시간 자동매매 실행 흐름 (`run_live.py`)

`run_live.py`는 자동 매매 계획을 수립하고, **매도 → 현금 재계산 → 매수**의 2단계 집행을 거쳐 주문을 실행하며, 이후 루프를 통해 체결 내역을 지속적으로 반영하고 결과를 기록하는 복잡한 과정을 지휘합니다.

**`run_live.py` 실행**
> **1. `main()` - 초기화 단계**
> > **파일**: `run_live.py`
> > **역할**: 스크립트의 **최상위 진입점**입니다. `_load_env_file()`로 환경 변수를 로드하고, `build_plan_auto()`를 호출하여 오늘의 매매 계획(스탑, 신호)을 수립하며, `KisBrokerAdapter`를 초기화하고 `fetch_cash`/`fetch_positions`로 **최초 계좌 상태**를 스냅샷합니다.
>
> **2. `build_orders()`**
> > **파일**: `live/order_router.py`
> > **역할**: **(주문 초안 생성)** 수립된 계획과 최초 계좌 상태를 바탕으로 오늘 실행할 **모든 주문(매수/매도)의 초안**을 생성합니다. 이 단계에서는 아직 예산을 고려하지 않습니다.
>
> **3. 1단계 집행: 매도 주문 실행**
> > **파일**: `run_live.py`
> > **역할**: 주문 초안에서 **매도(stop/rebalance) 주문만** 필터링하여 `place_order()` (from `live/broker_adapter.py`)를 통해 증권사에 먼저 전송합니다.
>
> **4. 중간 체결 수집 (선택 사항)**
> > **파일**: `run_live.py`
> > **역할**: `--collect-fills` 옵션이 켜져 있을 경우, `collect_fills_loop()` (from `live/fills.py`)를 호출하여 1단계 매도 주문의 **체결 내역을 수집**합니다. 이를 통해 확보된 현금을 파악합니다.
>
> **5. 현금 재조회 및 매수 예산 확정**
> > **파일**: `run_live.py`
> > **역할**: `fetch_cash()` (from `live/broker_adapter.py`)를 **다시 호출**하여 매도로 확보된 현금을 포함한 **최신 현금 잔고**를 가져옵니다. 이 금액을 기준으로 **실제 매수에 사용할 예산(budget)을 최종 확정**합니다.
>
> **6. 2단계 집행: 매수 주문 실행 및 다운사이징**
> > **파일**: `run_live.py`
> > **역할**: 확정된 예산 내에서 주문 초안의 매수 주문들을 비례적으로 축소(`proportional scaling`)하고, `_send_with_downsize` 함수를 통해 `place_order()`를 호출하여 최종 매수 주문을 전송합니다. 만약 증권사에서 잔고 부족으로 주문을 거절하면, **수량을 자동으로 줄여서 재시도(`downsize_retries`)**하는 로직이 포함되어 있습니다.
>
> **7. 루프 시작: 폴링 및 회계 처리 반복**
> > **파일**: `run_live.py`
> > **역할**: `--loop` 옵션이 활성화된 경우, 지정된 `max-runtime` 동안 주기적인 폴링 및 회계 처리를 반복 실행합니다.
> > * **`_collect_append()` (내부 함수)**: `poll-fills-every` 주기로 `collect_fills_loop()`를 호출하여 새로운 체결 내역을 지속적으로 수집하고 누적합니다.
> > * **`_reconcile_and_write()` (내부 함수)**: `reconcile-every` 주기로 `reconcile()` (from `live/reconcile.py`)을 호출하여 누적된 모든 체결 내역을 바탕으로 포지션과 현금 잔고를 갱신합니다. 이후 `finalize_outputs()` (from `live/outputs.py`)를 호출하여 최신 상태의 결과물을 파일로 덮어씁니다.
>
> **8. 최종 결과 출력**
> > **파일**: `run_live.py`
> > **역할**: 루프가 종료되거나, 단일 실행 모드일 경우, 마지막으로 `_reconcile_and_write()`를 호출하여 최종 결과물을 파일로 저장하고, 그 요약을 콘솔에 출력하며 모든 프로세스를 마무리합니다.

---

알겠습니다. `validate.py`의 오케스트레이션 과정을 각 단계별로 연결된 모든 **내부 함수와 다른 파일의 클래스 및 함수까지 포함**하여 정밀하게 분석하고 최종 완성본 다이어그램으로 설명해 드리겠습니다.

---

### 📊 검증 실행 흐름 (`validate.py`)

`validate.py`는 `backtest.py`가 생성한 결과물 디렉터리를 입력받아, **데이터 → 전략 → 시뮬레이션** 순서로 신뢰성을 감사하고, 최종적으로 사람이 이해하기 쉬운 분석 리포트를 생성하는 독립적인 검증 오케스트레이터입니다.

**`validate.py` 실행**
> **1. `main()` - 초기화 및 로드**
> > **파일**: `validate.py`
> > **역할**: 스크립트의 **최상위 진입점**입니다. 백테스트 결과물 디렉터리 경로를 인자로 받아 `_ensure_required()`를 호출하여 필수 파일(`trades.csv`, `metrics.json` 등)의 존재 여부를 확인하고, `_load_artifacts()`를 통해 모든 결과물을 메모리로 로드합니다. 이 과정에서 실패하면 즉시 종료됩니다.
>
> **2. `run()` (Data Gate)**
> > **파일**: `validation/data_gate.py`
> > **역할**: **(1단계: 데이터 무결성 감사)** 백테스트에 사용된 원본 데이터(스냅샷)가 약속된 형식과 내용을 그대로 유지하고 있는지 증명합니다.
> > * **`Artifacts` (클래스)**: 검증에 필요한 `snapshot_parquet_path`, `snapshot_meta` 등 파일 경로와 메타 정보를 구조화된 객체에 담아 전달합니다.
> > * **`_sha256_of_file()` 호출**: 스냅샷 Parquet 파일의 해시 값을 다시 계산하여 `snapshot_meta`에 기록된 값과 비교합니다. 불일치 시 데이터 변경으로 간주합니다.
> > * **Parquet 로드 및 인덱스 검증**: `pandas.read_parquet`로 파일을 직접 읽어 인덱스가 UTC 기준인지, 중복이나 시간 역전은 없는지 확인합니다.
> > * **메타데이터 대조**: 메타데이터에 기록된 행/열 개수, 시작/종료 시간이 실제 파일 내용과 일치하는지 대조합니다.
>
> **3. `run()` (Strategy Gate)**
> > **파일**: `validation/strategy_gate.py`
> > **역할**: **(2단계: 전략 규칙 감사)** 시뮬레이션이 '미래 데이터 참조 금지' 등 핵심 전략 규칙을 준수했는지 독립적으로 재계산하여 검증합니다.
> > * **전략 재계산**: 검증 게이트는 로드된 스냅샷 데이터를 바탕으로 **처음부터 다시** 이동평균, 신호(Signal), 스탑(Stop) 조건을 계산합니다.
> > * **타이밍 대조**: 실제 `trades.csv`에 기록된 모든 거래(`signal`, `stop`)가, 독립적으로 재계산된 신호/스탑 발생 시점과 정확히 일치하는지 타임스탬프를 기준으로 대조합니다.
> > * **우선순위 검증**: 동일 시각에 `stop`과 `signal` 거래가 모두 있다면, `trades.csv`에 `stop`이 항상 먼저 기록되었는지 확인하여 **'Stop > Signal'** 우선순위 규칙 준수 여부를 검사합니다.
>
> **4. `run()` (Simulation Gate)**
> > **파일**: `validation/simulation_gate.py`
> > **역할**: **(3단계: 회계 감사)** 시뮬레이션 엔진의 모든 계산 과정(체결가, 수수료, 자산 평가 등)이 수학적으로 정확한지 독립적으로 검증합니다.
> > * **거래별 감사**: `trades.csv`의 모든 거래에 대해 **기대 체결 가격**(`시가 × (1 ± 슬리피지)`), **수수료**, **수량의 `lot_step` 배수 여부**를 다시 계산하여 기록된 값과 비교합니다. `_round_price_nearest_tie_down`과 같은 자체 라운딩 함수를 사용합니다.
> > * **회계 장부 재구성**: 검증 게이트는 `trades.csv`와 스냅샷 데이터를 이용해 **독립적으로 일별 자산가치(equity)를 처음부터 끝까지 다시 계산**합니다.
> > * **결과 대조**: 재구성한 자산가치 시계열을 `equity_curve.csv`와 비교하고, 최종 수익률과 MDD 등의 지표를 `metrics.json`의 값과 대조하여 모든 숫자가 정확히 일치하는지 확인합니다.
>
> **5. `run()` (Analysis & Visualization)**
> > **파일**: `validation/analysis_viz.py`
> > **역할**: **(4단계: 리포트 생성)** 모든 검증을 통과한 신뢰성 있는 결과물을 바탕으로, 사람이 이해하기 쉬운 핵심 지표와 그래프를 생성합니다.
> > * **추가 지표 계산**: `_cagr` (연평균 복리수익률), `_rolling_sharpe` (롤링 샤프 지수) 등 분석에 필요한 추가 지표를 계산합니다.
> > * **그래프 생성 및 저장**: `matplotlib` 라이브러리를 사용하여 자본 곡선, 드로우다운 등의 그래프를 생성하고 `_save_png`를 통해 이미지 파일로 저장합니다.
> > * **`analysis_summary.json` 생성**: 모든 핵심 지표와 생성된 그래프 파일의 경로를 담은 최종 요약 보고서를 JSON 파일로 저장합니다.
>
> **6. 최종 요약 및 종료**
> > **파일**: `validate.py`
> > **역할**: 각 게이트의 실행 결과(`GateResult`)를 취합하여 `validation/gate_summary.json` 파일에 종합 리포트를 저장합니다. 하나라도 실패한 게이트가 있으면 스크립트는 **실패 종료 코드(1)**를, 모두 통과하면 **성공 종료 코드(0)**를 반환하며 모든 프로세스를 마무리합니다.
